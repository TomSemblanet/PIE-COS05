%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{Debris Removal Tool}
\date{Feb 09, 2022}
\release{Beta}
\author{Gaetan PIERRE, Come OOSTERHOF, Tom SEMBLANET, Myrtille MONCLIN, Yvan GARY}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstylestrong{Debris Removal Tool} (DRT) is a sample of python codes aiming to plan debris removal missions (consisting in multiple space rendezvous). For a given set of debris, DRT plans several missions, each one including 4 to 5 debris (by default).

It is focused on two major axes which are :
\begin{itemize}
\item {} 
the regroupement of the debris in order to plan optimal missions

\item {} 
the plannification of the multiple rendezvous missions

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
This project is under development.
\end{sphinxadmonition}


\chapter{Regroupement}
\label{\detokenize{regroupement:module-regroupement}}\label{\detokenize{regroupement:regroupement}}\label{\detokenize{regroupement::doc}}\index{module@\spxentry{module}!regroupement@\spxentry{regroupement}}\index{regroupement@\spxentry{regroupement}!module@\spxentry{module}}

\section{dV\_computations}
\label{\detokenize{regroupement/dV_computations:dv-computations}}\label{\detokenize{regroupement/dV_computations::doc}}

\subsection{Time evaluation for J2 perturbation transfer}
\label{\detokenize{regroupement/dV_computations:time-evaluation-for-j2-perturbation-transfer}}\phantomsection\label{\detokenize{regroupement/dV_computations:module-regroupement.dV_computations.compute_dt_alignment}}\index{module@\spxentry{module}!regroupement.dV\_computations.compute\_dt\_alignment@\spxentry{regroupement.dV\_computations.compute\_dt\_alignment}}\index{regroupement.dV\_computations.compute\_dt\_alignment@\spxentry{regroupement.dV\_computations.compute\_dt\_alignment}!module@\spxentry{module}}
Created on Wed Jan 26 18:09:33 2022

@author: g.pierre
\index{compute\_dt() (in module regroupement.dV\_computations.compute\_dt\_alignment)@\spxentry{compute\_dt()}\spxextra{in module regroupement.dV\_computations.compute\_dt\_alignment}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regroupement/dV_computations:regroupement.dV_computations.compute_dt_alignment.compute_dt}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regroupement.dV\_computations.compute\_dt\_alignment.}}\sphinxbfcode{\sphinxupquote{compute\_dt}}}{\emph{\DUrole{n}{a1}}, \emph{\DUrole{n}{a2}}, \emph{\DUrole{n}{i1}}, \emph{\DUrole{n}{i2}}, \emph{\DUrole{n}{RAAN1}}, \emph{\DUrole{n}{RAAN2}}, \emph{\DUrole{n}{print\_result}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Function computing the delta\_t {[}s{]} required to modify the RAAN of the orbit from RAAN1 to RAAN2
\begin{description}
\item[{Arguments}] \leavevmode{[}{]}
a1 (float) : Initial SMA {[}km{]}

a2 (float) : Final SMA {[}km{]}

i1 (float) : Initial inclination {[}rad{]}

i2 (float) : Final inclination {[}rad{]}

RAAN1 (float) : Initial Right ascension of the ascending node {[}rad{]}

RAAN2 (float) : Final Right ascension of the ascending node {[}rad{]}

\item[{Returns}] \leavevmode{[}{]}
dt\_days (float) : Required delta\_t {[}days{]}

\end{description}

\end{fulllineitems}

\index{compute\_dt\_matrix() (in module regroupement.dV\_computations.compute\_dt\_alignment)@\spxentry{compute\_dt\_matrix()}\spxextra{in module regroupement.dV\_computations.compute\_dt\_alignment}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regroupement/dV_computations:regroupement.dV_computations.compute_dt_alignment.compute_dt_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regroupement.dV\_computations.compute\_dt\_alignment.}}\sphinxbfcode{\sphinxupquote{compute\_dt\_matrix}}}{\emph{\DUrole{n}{debris\_data}}}{}
Function computing the delta\_t matrix of all possible transfer from a debris to another
\begin{description}
\item[{Arguments}] \leavevmode{[}{]}
debris\_data (dataframe) : Orbital parameters of the debris considered

\item[{Returns}] \leavevmode{[}{]}
dt\_matrix (array) : Matrix whose (i,j) indice represents the delta\_t (in seconds) required to modify the RAAN of the orbit from the RAAN of the debris i to the RAAN of the debris j

\end{description}

\end{fulllineitems}



\subsection{Computation of the delta\sphinxhyphen{}v associated to a maneuver}
\label{\detokenize{regroupement/dV_computations:computation-of-the-delta-v-associated-to-a-maneuver}}\phantomsection\label{\detokenize{regroupement/dV_computations:module-regroupement.dV_computations.maneuvers_dV}}\index{module@\spxentry{module}!regroupement.dV\_computations.maneuvers\_dV@\spxentry{regroupement.dV\_computations.maneuvers\_dV}}\index{regroupement.dV\_computations.maneuvers\_dV@\spxentry{regroupement.dV\_computations.maneuvers\_dV}!module@\spxentry{module}}
This module computes the delta\sphinxhyphen{}Vs necessary to change orbital parameters :
\begin{itemize}
\item {} 
SMA (semi\sphinxhyphen{}major axis)

\item {} 
ECC (eccentricity)

\item {} 
INC (inclination)

\item {} 
AOP (argument of perigee)

\item {} 
RAAN (right ascension of the ascending node)

\item {} 
TA (true anomaly)

\end{itemize}
\index{AOP\_dV() (in module regroupement.dV\_computations.maneuvers\_dV)@\spxentry{AOP\_dV()}\spxextra{in module regroupement.dV\_computations.maneuvers\_dV}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regroupement/dV_computations:regroupement.dV_computations.maneuvers_dV.AOP_dV}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regroupement.dV\_computations.maneuvers\_dV.}}\sphinxbfcode{\sphinxupquote{AOP\_dV}}}{\emph{\DUrole{n}{w1}}, \emph{\DUrole{n}{w2}}, \emph{\DUrole{n}{RAAN}}, \emph{\DUrole{n}{a}}, \emph{\DUrole{n}{e}}, \emph{\DUrole{n}{i}}, \emph{\DUrole{n}{m}}}{}
Computes the delta\sphinxhyphen{}V {[}km/s{]} required to modify the AOP of the orbit from w1 to w2
\begin{description}
\item[{Arguments}] \leavevmode{[}{]}
w1 (float) : Initial AOP {[}rad{]}

w2 (float) : Final AOP {[}rad{]}

RAAN (float) : Right ascension of the ascending node {[}rad{]}

a (float) : Semi\sphinxhyphen{}major axis {[}km{]}

e (float) : Eccentricity {[}\sphinxhyphen{}{]}

i (float) : Inclination {[}rad{]}

m (float) : Body’s mass {[}kg{]}

\item[{Returns}] \leavevmode{[}{]}
dV (float) : Required delta\sphinxhyphen{}V {[}km/s{]}

\end{description}

\end{fulllineitems}

\index{INC\_dV() (in module regroupement.dV\_computations.maneuvers\_dV)@\spxentry{INC\_dV()}\spxextra{in module regroupement.dV\_computations.maneuvers\_dV}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regroupement/dV_computations:regroupement.dV_computations.maneuvers_dV.INC_dV}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regroupement.dV\_computations.maneuvers\_dV.}}\sphinxbfcode{\sphinxupquote{INC\_dV}}}{\emph{\DUrole{n}{i1}}, \emph{\DUrole{n}{i2}}, \emph{\DUrole{n}{V1}}}{}
Computes the delta\sphinxhyphen{}V {[}km/s{]} required to modify the INC of the orbit from i1 to i2
\begin{description}
\item[{Arguments}] \leavevmode{[}{]}
a1 (float) : Initial INC {[}rad{]}

a2 (float) : Final INC {[}rad{]}

V1 (float) : Velocity on the orbit (supposed to be circular)

\item[{Returns}] \leavevmode{[}{]}
dV (float) : Required delta\sphinxhyphen{}V {[}km/s{]}

\end{description}

\end{fulllineitems}

\index{SMA\_dV() (in module regroupement.dV\_computations.maneuvers\_dV)@\spxentry{SMA\_dV()}\spxextra{in module regroupement.dV\_computations.maneuvers\_dV}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regroupement/dV_computations:regroupement.dV_computations.maneuvers_dV.SMA_dV}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regroupement.dV\_computations.maneuvers\_dV.}}\sphinxbfcode{\sphinxupquote{SMA\_dV}}}{\emph{\DUrole{n}{a1}}, \emph{\DUrole{n}{a2}}}{}
Computes the delta\sphinxhyphen{}V {[}km/s{]} required to modify the SMA of the orbit from ai to af
\begin{description}
\item[{Arguments}] \leavevmode{[}{]}
a1 (float) : Initial SMA {[}km{]}

a2 (float) : Final SMA {[}km{]}

\item[{Returns}] \leavevmode{[}{]}
dV (float) : Required delta\sphinxhyphen{}V {[}km/s{]}

\end{description}

\end{fulllineitems}



\subsection{Computation of the dV matrix used for the stochastic optimization}
\label{\detokenize{regroupement/dV_computations:computation-of-the-dv-matrix-used-for-the-stochastic-optimization}}\phantomsection\label{\detokenize{regroupement/dV_computations:module-0}}\index{module@\spxentry{module}!regroupement.dV\_computations.maneuvers\_dV@\spxentry{regroupement.dV\_computations.maneuvers\_dV}}\index{regroupement.dV\_computations.maneuvers\_dV@\spxentry{regroupement.dV\_computations.maneuvers\_dV}!module@\spxentry{module}}
This module computes the delta\sphinxhyphen{}Vs necessary to change orbital parameters :
\begin{itemize}
\item {} 
SMA (semi\sphinxhyphen{}major axis)

\item {} 
ECC (eccentricity)

\item {} 
INC (inclination)

\item {} 
AOP (argument of perigee)

\item {} 
RAAN (right ascension of the ascending node)

\item {} 
TA (true anomaly)

\end{itemize}
\index{AOP\_dV() (in module regroupement.dV\_computations.maneuvers\_dV)@\spxentry{AOP\_dV()}\spxextra{in module regroupement.dV\_computations.maneuvers\_dV}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regroupement/dV_computations:id0}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regroupement.dV\_computations.maneuvers\_dV.}}\sphinxbfcode{\sphinxupquote{AOP\_dV}}}{\emph{\DUrole{n}{w1}}, \emph{\DUrole{n}{w2}}, \emph{\DUrole{n}{RAAN}}, \emph{\DUrole{n}{a}}, \emph{\DUrole{n}{e}}, \emph{\DUrole{n}{i}}, \emph{\DUrole{n}{m}}}{}
Computes the delta\sphinxhyphen{}V {[}km/s{]} required to modify the AOP of the orbit from w1 to w2
\begin{description}
\item[{Arguments}] \leavevmode{[}{]}
w1 (float) : Initial AOP {[}rad{]}

w2 (float) : Final AOP {[}rad{]}

RAAN (float) : Right ascension of the ascending node {[}rad{]}

a (float) : Semi\sphinxhyphen{}major axis {[}km{]}

e (float) : Eccentricity {[}\sphinxhyphen{}{]}

i (float) : Inclination {[}rad{]}

m (float) : Body’s mass {[}kg{]}

\item[{Returns}] \leavevmode{[}{]}
dV (float) : Required delta\sphinxhyphen{}V {[}km/s{]}

\end{description}

\end{fulllineitems}

\index{INC\_dV() (in module regroupement.dV\_computations.maneuvers\_dV)@\spxentry{INC\_dV()}\spxextra{in module regroupement.dV\_computations.maneuvers\_dV}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regroupement/dV_computations:id1}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regroupement.dV\_computations.maneuvers\_dV.}}\sphinxbfcode{\sphinxupquote{INC\_dV}}}{\emph{\DUrole{n}{i1}}, \emph{\DUrole{n}{i2}}, \emph{\DUrole{n}{V1}}}{}
Computes the delta\sphinxhyphen{}V {[}km/s{]} required to modify the INC of the orbit from i1 to i2
\begin{description}
\item[{Arguments}] \leavevmode{[}{]}
a1 (float) : Initial INC {[}rad{]}

a2 (float) : Final INC {[}rad{]}

V1 (float) : Velocity on the orbit (supposed to be circular)

\item[{Returns}] \leavevmode{[}{]}
dV (float) : Required delta\sphinxhyphen{}V {[}km/s{]}

\end{description}

\end{fulllineitems}

\index{SMA\_dV() (in module regroupement.dV\_computations.maneuvers\_dV)@\spxentry{SMA\_dV()}\spxextra{in module regroupement.dV\_computations.maneuvers\_dV}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regroupement/dV_computations:id2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regroupement.dV\_computations.maneuvers\_dV.}}\sphinxbfcode{\sphinxupquote{SMA\_dV}}}{\emph{\DUrole{n}{a1}}, \emph{\DUrole{n}{a2}}}{}
Computes the delta\sphinxhyphen{}V {[}km/s{]} required to modify the SMA of the orbit from ai to af
\begin{description}
\item[{Arguments}] \leavevmode{[}{]}
a1 (float) : Initial SMA {[}km{]}

a2 (float) : Final SMA {[}km{]}

\item[{Returns}] \leavevmode{[}{]}
dV (float) : Required delta\sphinxhyphen{}V {[}km/s{]}

\end{description}

\end{fulllineitems}



\section{Optimizer}
\label{\detokenize{regroupement/optimizer:optimizer}}\label{\detokenize{regroupement/optimizer::doc}}

\subsection{Initialization of the first state}
\label{\detokenize{regroupement/optimizer:initialization-of-the-first-state}}\phantomsection\label{\detokenize{regroupement/optimizer:module-regroupement.optimizer.Init_alea_G}}\index{module@\spxentry{module}!regroupement.optimizer.Init\_alea\_G@\spxentry{regroupement.optimizer.Init\_alea\_G}}\index{regroupement.optimizer.Init\_alea\_G@\spxentry{regroupement.optimizer.Init\_alea\_G}!module@\spxentry{module}}
Created on 08/12/2021

@author: Yvan GARY
\index{Init\_alea\_G() (in module regroupement.optimizer.Init\_alea\_G)@\spxentry{Init\_alea\_G()}\spxextra{in module regroupement.optimizer.Init\_alea\_G}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regroupement/optimizer:regroupement.optimizer.Init_alea_G.Init_alea_G}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regroupement.optimizer.Init\_alea\_G.}}\sphinxbfcode{\sphinxupquote{Init\_alea\_G}}}{\emph{\DUrole{n}{nb\_debris}}, \emph{\DUrole{n}{s\_min}}, \emph{\DUrole{n}{s\_max}}, \emph{\DUrole{n}{DV}}, \emph{\DUrole{n}{DT}}}{}
Function used to initiate the optimization
\begin{description}
\item[{Arguments:}] \leavevmode
nb\_debris (int): Number of debris in the given catalogue

s\_min (int) : Minimum number of debris contained in a group

s\_max (int) : Maximum number of debris contained in a group

DV (Matrix): Matrix containing the delta\_v associated to each maneuver

DT (Matrix): Matrix containing the elapsed time associated to each “J2 perturbation duration” between two debris

\item[{Returns:}] \leavevmode
G (matrix): First state generated randomly to begin Optimization

E (float): Energy associated to the state G

\end{description}

\end{fulllineitems}



\subsection{Computation of the energy associated to a state}
\label{\detokenize{regroupement/optimizer:computation-of-the-energy-associated-to-a-state}}\phantomsection\label{\detokenize{regroupement/optimizer:module-regroupement.optimizer.energy_computation}}\index{module@\spxentry{module}!regroupement.optimizer.energy\_computation@\spxentry{regroupement.optimizer.energy\_computation}}\index{regroupement.optimizer.energy\_computation@\spxentry{regroupement.optimizer.energy\_computation}!module@\spxentry{module}}
Created on 09/12/2021

@author: Yvan GARY
\index{energy\_computation() (in module regroupement.optimizer.energy\_computation)@\spxentry{energy\_computation()}\spxextra{in module regroupement.optimizer.energy\_computation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regroupement/optimizer:regroupement.optimizer.energy_computation.energy_computation}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regroupement.optimizer.energy\_computation.}}\sphinxbfcode{\sphinxupquote{energy\_computation}}}{\emph{\DUrole{n}{G}}, \emph{\DUrole{n}{DV}}, \emph{\DUrole{n}{DT}}, \emph{\DUrole{n}{detail}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Function used to compute the energy associated to a state
\begin{description}
\item[{Arguments:}] \leavevmode
G (Matrix): Actual state for which we compute the energy

DV (Matrix): Matrix containing the delta\_v associated to each maneuver

DT (Matrix): Matrix containing the elapsed time associated to each “J2 perturbation duration” between two debris

detail (bool) : False by default \sphinxhyphen{} If True, gives the detail of the energy for each group

\item[{Returns: }] \leavevmode
E (float): Energy associated to the state G

E\_transfers (array) \sphinxhyphen{} optionnal : Energy associated to each individual group

E\_transfers\_dV (array) \sphinxhyphen{} optionnal : delta v associated to each individual group

E\_transfers\_dt (array) \sphinxhyphen{} optionnal : elapsed time due to J2 perturbation associated to each individual group

\end{description}

\end{fulllineitems}

\index{energy\_computation\_DT() (in module regroupement.optimizer.energy\_computation)@\spxentry{energy\_computation\_DT()}\spxextra{in module regroupement.optimizer.energy\_computation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regroupement/optimizer:regroupement.optimizer.energy_computation.energy_computation_DT}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regroupement.optimizer.energy\_computation.}}\sphinxbfcode{\sphinxupquote{energy\_computation\_DT}}}{\emph{\DUrole{n}{G}}, \emph{\DUrole{n}{DT}}, \emph{\DUrole{n}{detail}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Function used to compute the delta t (J2) associated to a state
\begin{description}
\item[{Arguments:}] \leavevmode
G (Matrix): Actual state for which we compute the energy

DV (Matrix): Matrix containing the delta\_v associated to each maneuver

detail (bool) : False by default \sphinxhyphen{} If True, gives the detail of the delta v for each group

\item[{Returns: }] \leavevmode
dV (float): Global delta v associated to the state G

dV\_transfers (array) \sphinxhyphen{} optionnal : Global delta v associated to each individual group

\end{description}

\end{fulllineitems}

\index{energy\_computation\_DV() (in module regroupement.optimizer.energy\_computation)@\spxentry{energy\_computation\_DV()}\spxextra{in module regroupement.optimizer.energy\_computation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regroupement/optimizer:regroupement.optimizer.energy_computation.energy_computation_DV}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regroupement.optimizer.energy\_computation.}}\sphinxbfcode{\sphinxupquote{energy\_computation\_DV}}}{\emph{\DUrole{n}{G}}, \emph{\DUrole{n}{DV}}, \emph{\DUrole{n}{detail}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Function used to compute the delta v associated to a state
\begin{description}
\item[{Arguments:}] \leavevmode
G (Matrix): Actual state for which we compute the energy

DV (Matrix): Matrix containing the delta\_v associated to each maneuver

detail (bool) : False by default \sphinxhyphen{} If True, gives the detail of the delta v for each group

\item[{Returns: }] \leavevmode
dV (float): Global delta v associated to the state G

dV\_transfers (array) \sphinxhyphen{} optionnal : Global delta v associated to each individual group

\end{description}

\end{fulllineitems}



\subsection{Implementation of the dynamic of Metropolis}
\label{\detokenize{regroupement/optimizer:implementation-of-the-dynamic-of-metropolis}}\phantomsection\label{\detokenize{regroupement/optimizer:module-regroupement.optimizer.Metropolis}}\index{module@\spxentry{module}!regroupement.optimizer.Metropolis@\spxentry{regroupement.optimizer.Metropolis}}\index{regroupement.optimizer.Metropolis@\spxentry{regroupement.optimizer.Metropolis}!module@\spxentry{module}}
Created on 08/12/2021

@author: Yvan GARY
\index{Metropolis() (in module regroupement.optimizer.Metropolis)@\spxentry{Metropolis()}\spxextra{in module regroupement.optimizer.Metropolis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regroupement/optimizer:regroupement.optimizer.Metropolis.Metropolis}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regroupement.optimizer.Metropolis.}}\sphinxbfcode{\sphinxupquote{Metropolis}}}{\emph{\DUrole{n}{G\_in}}, \emph{\DUrole{n}{E\_in}}, \emph{\DUrole{n}{s\_min}}, \emph{\DUrole{n}{s\_max}}, \emph{\DUrole{n}{DV}}, \emph{\DUrole{n}{DT}}, \emph{\DUrole{n}{T}}}{}~\begin{description}
\item[{Function computing the dynamic of Metropolis. }] \leavevmode
A neighbour of a state G is defined as a switch of two debris between two groups selected randomly. 
Then it is kept or abandonned according to the Metropolis dynamic.

\item[{Arguments:}] \leavevmode
G\_in (Matrix): Current state  i.e. current regroupments of debris

E\_in (float): Energy associated to the current state G\_in

s\_min (int) : Minimum number of debris contained in a group

s\_max (int) : Maximum number of debris contained in a group

DV (Matrix): Matrix containing the delta\_v associated to each maneuver

DT (Matrix): Matrix containing the elapsed time associated to each “J2 perturbation duration” between two debris

T (float) : Temperature related to the dynamic of Metropolis

\item[{Returns:}] \leavevmode
G\_out (Matrix): Output state of the dynamic of Metropolis

E\_out (float): Energy associated to the new state G\_out

\end{description}

\end{fulllineitems}

\index{select\_random\_debris() (in module regroupement.optimizer.Metropolis)@\spxentry{select\_random\_debris()}\spxextra{in module regroupement.optimizer.Metropolis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regroupement/optimizer:regroupement.optimizer.Metropolis.select_random_debris}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regroupement.optimizer.Metropolis.}}\sphinxbfcode{\sphinxupquote{select\_random\_debris}}}{\emph{\DUrole{n}{G}}, \emph{\DUrole{n}{grps}}, \emph{\DUrole{n}{card\_grps}}}{}
Function selecting randomly one debris in each group in grps (used to compute neighbours)
\begin{description}
\item[{Arguments:}] \leavevmode
G (Matrix) : Current state  i.e. current regroupments of debris

grps (1d\sphinxhyphen{}array) : Array containing the groups (of same size) indices

card\_grps (int) : Number of debris contained in each group (the same for every group), typically s\_max

\item[{Returns:}] \leavevmode
selected\_debris (1d\sphinxhyphen{}array) : Array containing the indices of the selected debris in each group (same order as groups)

\end{description}

\end{fulllineitems}

\index{split\_and\_fill() (in module regroupement.optimizer.Metropolis)@\spxentry{split\_and\_fill()}\spxextra{in module regroupement.optimizer.Metropolis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regroupement/optimizer:regroupement.optimizer.Metropolis.split_and_fill}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regroupement.optimizer.Metropolis.}}\sphinxbfcode{\sphinxupquote{split\_and\_fill}}}{\emph{\DUrole{n}{G}}, \emph{\DUrole{n}{grps}}, \emph{\DUrole{n}{grp\_idx}}}{}
Function selecting randomly a group to split and groups to be filled (used to compute neighbours)
\begin{description}
\item[{Arguments:}] \leavevmode
G (Matrix) : Current state  i.e. current regroupements of debris

grps (1d\sphinxhyphen{}array) : Array containing the groups (of same size) indices

grp\_idx (1d\_array) : indices of the group that can be filled (with cardinal \textless{} s\_max)

\item[{Returns:}] \leavevmode
G (Matrix) : Current state  i.e. current regroupements of debris after distribution

\end{description}

\end{fulllineitems}



\subsection{Simulated Annealing}
\label{\detokenize{regroupement/optimizer:simulated-annealing}}\phantomsection\label{\detokenize{regroupement/optimizer:module-regroupement.optimizer.Recuit}}\index{module@\spxentry{module}!regroupement.optimizer.Recuit@\spxentry{regroupement.optimizer.Recuit}}\index{regroupement.optimizer.Recuit@\spxentry{regroupement.optimizer.Recuit}!module@\spxentry{module}}
Created on 13/12/2021

@author: Yvan GARY
\index{Recuit() (in module regroupement.optimizer.Recuit)@\spxentry{Recuit()}\spxextra{in module regroupement.optimizer.Recuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regroupement/optimizer:regroupement.optimizer.Recuit.Recuit}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{regroupement.optimizer.Recuit.}}\sphinxbfcode{\sphinxupquote{Recuit}}}{\emph{\DUrole{n}{nb\_debris}}, \emph{\DUrole{n}{s\_min}}, \emph{\DUrole{n}{s\_max}}, \emph{\DUrole{n}{DV}}, \emph{\DUrole{n}{DT}}, \emph{\DUrole{n}{Ti}}, \emph{\DUrole{n}{Tf}}, \emph{\DUrole{n}{alpha}}, \emph{\DUrole{n}{n\_classes}}, \emph{\DUrole{n}{t\_iter}}, \emph{\DUrole{n}{n\_iter}}}{}~\begin{description}
\item[{Function computing the simulated annealing, with the corresponding dynamic of Metropolis.}] \leavevmode
It corresponds to the succession of Markov chains computed with decreasing temperatures. At the end
we obtain a state G\_out that minimizes the energy we defined, that is to say the sum of the delta\_v
associated to each groups. G\_out contains the final groups that reach this minimal “global delta\_v”.

\item[{Arguments:}] \leavevmode
nb\_debris (int) : Nulber of debris in the given catalogue

s\_min (int) : Minimum number of debris contained in a group

s\_max (int) : Maximum number of debris contained in a group

DV (Matrix) : Matrix containing the delta\_v associated to each maneuver

DT (Matrix): Matrix containing the elapsed time associated to each “J2 perturbation duration” between two debris

Ti (float) : Initial temperature related to the dynamic of Metropolis

Tf (float) : Final temperature related to the dynamic of Metropolis

alpha (float) : Geometric factor to decrease Temperature (0 \textless{} alpha \textless{} 1)

n\_classes (array) : Number of classes for the displayed histogram (ex : range(100))

t\_iter (int) : Number of iterations for a Markov chain

n\_iter (int) : Number of Markov chains generated for each Temperature

\item[{Returns:}] \leavevmode
G\_out (matrix) : Output state of the dynamic of Metropolis

E\_out (float) : Energy associated to the new state G\_out

freqs (array) : Frequencies associated to each energy

\end{description}

\end{fulllineitems}



\chapter{Utils}
\label{\detokenize{utils:utils}}\label{\detokenize{utils::doc}}

\section{Change of coordinates}
\label{\detokenize{utils:change-of-coordinates}}\phantomsection\label{\detokenize{utils:module-utils.coc}}\index{module@\spxentry{module}!utils.coc@\spxentry{utils.coc}}\index{utils.coc@\spxentry{utils.coc}!module@\spxentry{module}}\index{cart2kep() (in module utils.coc)@\spxentry{cart2kep()}\spxextra{in module utils.coc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils:utils.coc.cart2kep}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.coc.}}\sphinxbfcode{\sphinxupquote{cart2kep}}}{\emph{\DUrole{n}{R}}, \emph{\DUrole{n}{V}}, \emph{\DUrole{n}{mu}}}{}
Converts coordinates of a body from its cartesian coordinates into its orbitals elements (coe)

Arguments :
\begin{quote}

R (array) : Position of the body in the ECI frame

V (array) : Velocity of the body in the ECI frame

mu (float) : Characteristic parameter of the central body
\end{quote}
\begin{description}
\item[{Returns}] \leavevmode{[}{]}
coe (array) : Body’s orbital elements (SMA, ECC, INC, AOP, RAAN, TA)

\end{description}

\end{fulllineitems}

\index{kep2cart() (in module utils.coc)@\spxentry{kep2cart()}\spxextra{in module utils.coc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils:utils.coc.kep2cart}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.coc.}}\sphinxbfcode{\sphinxupquote{kep2cart}}}{\emph{\DUrole{n}{coe}}, \emph{\DUrole{n}{mu}}}{}
Converts coordinates of a body from orbital elements (coe) into cartesian coordinates 
Arguments :
\begin{quote}

coe (array) : Orbital elements of the body (SMA, ECC, INC, AOP, RAAN, TA)

mu (float) : Characteristic parameter of the central body
\end{quote}
\begin{description}
\item[{Returns}] \leavevmode{[}{]}
r (array) : Concatenation of the body’s position and velocity (X, Y, Z, VX, VY, VZ) in the geocentric frame

\end{description}

\end{fulllineitems}



\section{Useful constants}
\label{\detokenize{utils:useful-constants}}\phantomsection\label{\detokenize{utils:module-utils.constants}}\index{module@\spxentry{module}!utils.constants@\spxentry{utils.constants}}\index{utils.constants@\spxentry{utils.constants}!module@\spxentry{module}}

\section{Loading debris data}
\label{\detokenize{utils:loading-debris-data}}\phantomsection\label{\detokenize{utils:module-utils.debris_data_loader}}\index{module@\spxentry{module}!utils.debris\_data\_loader@\spxentry{utils.debris\_data\_loader}}\index{utils.debris\_data\_loader@\spxentry{utils.debris\_data\_loader}!module@\spxentry{module}}
Created on Wed Nov 24 10:19:33 2021

@author: g.pierre
\index{convertTLEtoDF() (in module utils.debris\_data\_loader)@\spxentry{convertTLEtoDF()}\spxextra{in module utils.debris\_data\_loader}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils:utils.debris_data_loader.convertTLEtoDF}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.debris\_data\_loader.}}\sphinxbfcode{\sphinxupquote{convertTLEtoDF}}}{\emph{\DUrole{n}{TLE\_String}}}{}
Function which aims to convert data in TLE format towards pandas dataframe (for our set of debris)

Arguments :
\begin{quote}

TLE\_String (string) : Concatenated TLEs (string) of each object
\end{quote}

Returns :
\begin{quote}

TLE\_DF (pandas dataframe) : DataFrame containing orbital parameters, time and mass for each debris
\end{quote}

\end{fulllineitems}

\index{recoveringDebrisData() (in module utils.debris\_data\_loader)@\spxentry{recoveringDebrisData()}\spxextra{in module utils.debris\_data\_loader}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utils:utils.debris_data_loader.recoveringDebrisData}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utils.debris\_data\_loader.}}\sphinxbfcode{\sphinxupquote{recoveringDebrisData}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Function which aims to recover data from orbiting objects from Space\sphinxhyphen{}Track.org

Arguments :
\begin{quote}

args (list of int) : Norad IDs of objects of interest, default value is the list given in constant.py
\end{quote}

Returns :
\begin{quote}

TLE\_String (string) : Concatenated TLEs (string) of each object
\end{quote}

\end{fulllineitems}



\section{General calculus}
\label{\detokenize{utils:general-calculus}}\phantomsection\label{\detokenize{utils:module-utils.general_calculus}}\index{module@\spxentry{module}!utils.general\_calculus@\spxentry{utils.general\_calculus}}\index{utils.general\_calculus@\spxentry{utils.general\_calculus}!module@\spxentry{module}}
This module computes intermadiary data like velocity, 
angular momentum, effect of J2 perturbation on RAAN


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{r}
\item\relax\sphinxstyleindexentry{regroupement}\sphinxstyleindexpageref{regroupement:\detokenize{module-regroupement}}
\item\relax\sphinxstyleindexentry{regroupement.dV\_computations.compute\_dt\_alignment}\sphinxstyleindexpageref{regroupement/dV_computations:\detokenize{module-regroupement.dV_computations.compute_dt_alignment}}
\item\relax\sphinxstyleindexentry{regroupement.dV\_computations.maneuvers\_dV}\sphinxstyleindexpageref{regroupement/dV_computations:\detokenize{module-0}}
\item\relax\sphinxstyleindexentry{regroupement.optimizer.energy\_computation}\sphinxstyleindexpageref{regroupement/optimizer:\detokenize{module-regroupement.optimizer.energy_computation}}
\item\relax\sphinxstyleindexentry{regroupement.optimizer.Init\_alea\_G}\sphinxstyleindexpageref{regroupement/optimizer:\detokenize{module-regroupement.optimizer.Init_alea_G}}
\item\relax\sphinxstyleindexentry{regroupement.optimizer.Metropolis}\sphinxstyleindexpageref{regroupement/optimizer:\detokenize{module-regroupement.optimizer.Metropolis}}
\item\relax\sphinxstyleindexentry{regroupement.optimizer.Recuit}\sphinxstyleindexpageref{regroupement/optimizer:\detokenize{module-regroupement.optimizer.Recuit}}
\indexspace
\bigletter{u}
\item\relax\sphinxstyleindexentry{utils.coc}\sphinxstyleindexpageref{utils:\detokenize{module-utils.coc}}
\item\relax\sphinxstyleindexentry{utils.constants}\sphinxstyleindexpageref{utils:\detokenize{module-utils.constants}}
\item\relax\sphinxstyleindexentry{utils.debris\_data\_loader}\sphinxstyleindexpageref{utils:\detokenize{module-utils.debris_data_loader}}
\item\relax\sphinxstyleindexentry{utils.general\_calculus}\sphinxstyleindexpageref{utils:\detokenize{module-utils.general_calculus}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}